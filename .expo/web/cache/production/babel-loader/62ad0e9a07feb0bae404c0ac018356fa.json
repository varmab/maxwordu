{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{useState,useEffect}from'react';import NativeEventEmitter from\"react-native-web/dist/exports/NativeEventEmitter\";import NativeModules from\"react-native-web/dist/exports/NativeModules\";export function useOnMount(asyncGetter,initialResult){var _useState=useState({loading:true,result:initialResult}),_useState2=_slicedToArray(_useState,2),response=_useState2[0],setResponse=_useState2[1];useEffect(function(){var getAsync=function _callee(){var result;return _regeneratorRuntime.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _regeneratorRuntime.awrap(asyncGetter());case 2:result=_context.sent;setResponse({loading:false,result:result});case 4:case\"end\":return _context.stop();}}},null,null,null,Promise);};getAsync();},[asyncGetter]);return response;}export var deviceInfoEmitter=new NativeEventEmitter(NativeModules.RNDeviceInfo);export function useOnEvent(eventName,initialValueAsyncGetter,defaultValue){var _useOnMount=useOnMount(initialValueAsyncGetter,defaultValue),loading=_useOnMount.loading,initialResult=_useOnMount.result;var _useState3=useState(defaultValue),_useState4=_slicedToArray(_useState3,2),result=_useState4[0],setResult=_useState4[1];useEffect(function(){setResult(initialResult);},[initialResult]);useEffect(function(){var subscription=deviceInfoEmitter.addListener(eventName,setResult);return function(){return subscription.remove();};},[eventName]);return{loading:loading,result:result};}","map":{"version":3,"sources":["asyncHookWrappers.ts"],"names":["useState","loading","result","initialResult","useEffect","getAsync","asyncGetter","setResponse","deviceInfoEmitter","NativeModules","useOnMount","setResult","subscription"],"mappings":"6HAAA,OAAA,QAAA,CAAA,SAAA,KAAA,OAAA,C,wJASA,MAAO,SAAA,CAAA,UAAA,CAAA,WAAA,CAAA,aAAA,CAA4F,CACjG,cAAgCA,QAAQ,CAAqB,CAC3DC,OAAO,CADoD,IAAA,CAE3DC,MAAM,CAAEC,aAFmD,CAArB,CAAxC,wCAAM,QAAN,eAAM,WAAN,eAKAC,SAAS,CAAC,UAAM,CAEd,GAAMC,CAAAA,QAAQ,CAAG,gMACMC,WAArB,EADe,SACTJ,MADS,eAEfK,WAAW,CAAC,CAAEN,OAAO,CAAT,KAAA,CAAkBC,MAAAA,CAAAA,MAAlB,CAAD,CAAXK,CAFe,qEAAjB,CAKAF,QAAQ,GAPD,CAAA,CAQN,CARHD,WAQG,CARM,CAATA,CAUA,MAAA,CAAA,QAAA,CACD,CAED,MAAO,IAAMI,CAAAA,iBAAiB,CAAG,GAAA,CAAA,kBAAA,CAAuBC,aAAa,CAA9D,YAA0B,CAA1B,CAQP,MAAO,SAAA,CAAA,UAAA,CAAA,SAAA,CAAA,uBAAA,CAAA,YAAA,CAIe,CACpB,gBAA2CC,UAAU,CAAA,uBAAA,CAArD,YAAqD,CAArD,CAAM,OAAN,aAAM,OAAN,CAAyBP,aAAzB,aAAiBD,MAAjB,CACA,eAA4BF,QAAQ,CAFhB,YAEgB,CAApC,yCAAM,MAAN,eAAM,SAAN,eAGAI,SAAS,CAAC,UAAM,CACdO,SAAS,CAATA,aAAS,CAATA,CADO,CAAA,CAEN,CAPiB,aAOjB,CAFM,CAATP,CAMAA,SAAS,CAAC,UAAM,CACd,GAAMQ,CAAAA,YAAY,CAAGJ,iBAAiB,CAAjBA,WAAAA,CAAAA,SAAAA,CAArB,SAAqBA,CAArB,CACA,MAAO,kBAAMI,CAAAA,YAAY,CAAzB,MAAaA,EAAN,EAAP,CAFO,CAAA,CAGN,CAdiB,SAcjB,CAHM,CAATR,CAMA,MAAO,CAAEH,OAAF,CAAEA,OAAF,CAAWC,MAAAA,CAAAA,MAAX,CAAP,CACD","sourcesContent":["import { useState, useEffect } from 'react';\nimport { NativeEventEmitter, NativeModules } from 'react-native';\nimport type { AsyncHookResult } from './types';\n\n/**\n * simple hook wrapper for async functions for 'on-mount / componentDidMount' that only need to fired once\n * @param asyncGetter async function that 'gets' something\n * @param initialResult -1 | false | 'unknown'\n */\nexport function useOnMount<T>(asyncGetter: () => Promise<T>, initialResult: T): AsyncHookResult<T> {\n  const [response, setResponse] = useState<AsyncHookResult<T>>({\n    loading: true,\n    result: initialResult,\n  });\n\n  useEffect(() => {\n    // async function cuz react complains if useEffect's effect param is an async function\n    const getAsync = async () => {\n      const result = await asyncGetter();\n      setResponse({ loading: false, result });\n    };\n\n    getAsync();\n  }, [asyncGetter]);\n\n  return response;\n}\n\nexport const deviceInfoEmitter = new NativeEventEmitter(NativeModules.RNDeviceInfo);\n\n/**\n * simple hook wrapper for handling events\n * @param eventName\n * @param initialValueAsyncGetter\n * @param defaultValue\n */\nexport function useOnEvent<T>(\n  eventName: string,\n  initialValueAsyncGetter: () => Promise<T>,\n  defaultValue: T\n): AsyncHookResult<T> {\n  const { loading, result: initialResult } = useOnMount(initialValueAsyncGetter, defaultValue);\n  const [result, setResult] = useState<T>(defaultValue);\n\n  // sets the result to what the intial value is on mount\n  useEffect(() => {\n    setResult(initialResult);\n  }, [initialResult]);\n\n  // - set up the event listener to set the result\n  // - set up the clean up function to remove subscription on unmount\n  useEffect(() => {\n    const subscription = deviceInfoEmitter.addListener(eventName, setResult);\n    return () => subscription.remove();\n  }, [eventName]);\n\n  // loading will only be true while getting the inital value. After that, it will always be false, but a new result may occur\n  return { loading, result };\n}\n"]},"metadata":{},"sourceType":"module"}